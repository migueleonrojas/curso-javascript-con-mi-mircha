<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This tipos de datos</title>
</head>
<body>
    <h1>This tipos de datos</h1>
    <script>
        

        /* Video 49) Symbols */

        /* //symbol crea una referencia unica, se pueden usar para crear propiedades privadas para los
        //objetos

        let id = Symbol("id");
        let id2 = Symbol("id2");

        console.log(id === id2);
        console.log(id, id2);
        console.log(typeof id, typeof id2);

        //creando un simbolo con buenas practicas
        const NOMBRE = Symbol("nombre");

        const SALUDAR = Symbol("saludar");

        const persona = {
            //asignando un simbolo como propiedad
            [NOMBRE]:"jon",
            edad: 35
        }

        console.log(persona);

        persona.NOMBRE = "Jonathan";

        console.log(persona);

        console.log(persona.NOMBRE);

        console.log(persona[NOMBRE]);//llamando la propiedad que es un simbolo

        //agregando un simbolo como propiedad al objeto que alberga una funcion
        persona[SALUDAR] = function(){
            console.log("Hola");
        }

        console.log(persona);

        console.log(persona[SALUDAR]());//ejecutanto la funcion que contiene el symbol

        for(let propiedad in persona){
            console.log(propiedad);//me indica el nombre de la propiedad

            console.log(persona[propiedad]);//me da el valor de la propiedad
        }

        //para listar los simbolos del objeto
        console.log(Object.getOwnPropertySymbols(persona)); */

        /* Fin Video 49) Symbols */

        /* Video 50) Sets */

        /* //set= array de datos unicos

        const set = new Set([1,2,3,3,4,5,true, false, false, {}, {}, "hola", "Hola"]);

        console.log(set);

        console.log(set.size);


        const set2 = new Set();
        
        //agregando valores
        set2.add(1);
        set2.add(2);
        set2.add(2);
        set2.add(3);
        set2.add(true);
        set2.add(false);
        set2.add(true);
        set2.add({});
        

        console.log(set2);
        console.log(set2.size);

        console.log("Recorriendo set");
        //recorrer los elementos
        for(item of set){

            console.log(item);

        }

        console.log("Recorriendo set 2");
        set2.forEach(item => console.log(item));

        //convierte un objeto a arreglo para poder acceder al elemento por la posicion
        let arr = Array.from(set);
        console.log(arr[0]);

        //eliminando un valor del set
        set.delete("Hola");

        console.log(set);

        //valida si el valor existe en el objeto set
        console.log(set.has("hola"));

        set2.clear();//elimina todos los valores del objeto

        console.log(set2); */
        /* Fin Video 50) Sets */

        /* Video 51) Maps */

        /* //map = coleccion de datos como un objeto primitivo

        const mapa = new Map();

        //establecer una propiedad con su valor
        mapa.set("nombre", "jon");
        mapa.set("apellido", "mircha");
        mapa.set("edad", 35);

        console.log(mapa);
        console.log(mapa.size);

        //valida si existe la propiedad correo
        console.log(mapa.has("correo"));
        console.log(mapa.has("nombre"));

        //para obtener el valor a traves de la propiedad
        console.log(mapa.get("nombre"));

        //sobreescribir un valor a traves de la propiedad
        console.log(mapa.set("nombre","jonathan"));

        console.log(mapa.get("nombre"));

        //eliminar elemento de un map
        mapa.delete("apellido");

        //se puede colocar como propiedad un valor que no sea una cadena de texto
        mapa.set(19, "diecinueve");
        mapa.set(false, "falso");
        mapa.set({}, {});

        console.log(mapa);

        //recorriendo un mapa
        for(let [key, value] of mapa){
            console.log(`Llave: ${key}, Valor: ${value}`);
        }

        //declarando y inicializando un map
        const mapa2 = new Map([
            ["nombre", "kenai"],
            ["edad","7"],
            ["animal", "perro"],
            [null,"nulo"]
            
        ]);

        console.log(mapa2);

        const llavesMapa2 = [...mapa2.keys()];
        const valoresMapa2 = [...mapa2.values()];

        console.log(llavesMapa2);
        console.log(valoresMapa2); */

        /* Fin Video 51) Maps */

        /* Video 52) WeakSets & WeakMaps */

        /* //no se puede inicializar los valores, debe usarse el metodo add
        //const ws = new WeakSet([
        //    1, 2, 3, 3, 4, 5, true, false, false, {}, {}, "hola", "Hola" 
        //])

        //const ws = new WeakSet();

        //let valor1 = {"valor1":1};
        //let valor2 = {"valor1":2};
        //let valor3 = {"valor1":3};

        //solo acepta referencias debiles es decir objetos
        //ws.add(valor1);
        //ws.add(valor2);

        //console.log(ws);

        //validando si la referencia debil existe
        //console.log(ws.has(valor1));
        //console.log(ws.has(valor3));

        //eliminando la referncia
        //ws.delete(ws.delete(valor2));

        //console.log(ws);

        //ws.add(valor2);
        //ws.add(valor3);

        //console.log(ws);

        //setInterval(() => console.log(ws), 100);

        //setTimeout(() => {
            //cuando se vuelve nulo la referencia debil entonces el weakseak los envia al
            //recolector de basura y es como que ya no tuviera propiedades el weakseak
        //    valor1 = null;
        //    valor2 = null;
        //    valor3 = null;
        //}, 5000);


        //weakmap

        //no se puede inicializar los valores, debe usarse el metodo add
        //const wm = new WeakMap([
        //    ["nombre","kenai"],
        //    ["edad", 7],
        //    ["animal","perro"],
        //    [ null, "nulo"]
        //]);

        const wm = new WeakMap();

        let llave1 = {};
        let llave2 = {};
        let llave3 = {};
        
        //se puede agregar la referencia debil asi
        wm.set(llave1,1);
        wm.set(llave2,2);
        
        console.log(wm);

        //para saber si existe una referencia o no dentro del weakmap
        console.log(wm.has(llave1));
        console.log(wm.has(llave3));


        //obtener el valor de una llave en particular
        console.log(wm.get(llave1))
        console.log(wm.get(llave2))
        console.log(wm.get(llave3))

        //eliminar una llave en particular
        wm.delete(llave2);
        console.log(wm);

        wm.set(llave2,2);
        wm.set(llave3,3);

        console.log(wm);

        setInterval(() => console.log(wm), 1000);

        setTimeout(() => {

            llave1 = null;
            llave2 = null;
            llave3 = null;

        },5000) */


        /* Fin Video 52) WeakSets & WeakMaps */

        /* Video 53) Iterables & Iterators */

        
        /* const iterable = [1,2,3,4,5];

        //accedemos al iterador del iterable, 
        //iterador = es una interfaz especial que tenemos para recorrer elementos que sean iterables
        const iterador = iterable[Symbol.iterator]();

        console.log(iterable);
        console.log(iterador);

        //iterador que recorre los elementos del iterable y next lo que hace es pasar al proximo valor
        //a iterar
        //console.log(iterador.next());
        //console.log(iterador.next());
        //console.log(iterador.next());
        //console.log(iterador.next());
        //console.log(iterador.next());
        //console.log(iterador.next());

        let next = iterador.next();

        while (!next.done) {
            console.log(next.value);
            next = iterador.next();
        } */

        /* Fin Video 53) Iterables & Iterators */

        /* Video 54) Generators */

        /* //generator = una forma mas sencilla de crear iteradores
        //para volver iterables a una funcion

        //se coloca = "function*" para indicar que la funcion es un generador
        function* iterable(){
            //es un return que cada vez que se hace next llega la ejecucion de la funcion
            //hasta este yield, en el proximo next busca desde este yield a proximo yield para
            //ejecutar esa parte de la funcion
            yield "hola";
            console.log("Hola consola");
            yield "hola2";
            console.log("Seguimos con mas instrucciones de nuestro codigo");
            yield "hola3";
            yield "hola4";

        }

        //se accede a la interfaz del iterador
        let iterador = iterable();

        //console.log(iterador.next());
        //console.log(iterador.next());
        //console.log(iterador.next());
        //console.log(iterador.next());
        //console.log(iterador.next());

        for(let y of iterador){
            console.log(y);
        }

        //almacenar los yield de una funcion generadora en un array
        const arr = [...iterable()];
        console.log(arr);


        function cuadrado(valor){
            setTimeout(() => {

                return console.log({valor, resultado: valor * valor})

            },Math.random() * 1000);

        }

        function* generador(){
            console.log("Inicia generator");

            yield cuadrado(0);
            yield cuadrado(1);
            yield cuadrado(2);
            yield cuadrado(3);
            yield cuadrado(4);
            yield cuadrado(5);

            console.log("Termina generator");
        } 

        let gen = generador();

        for(let y of gen){
            console.log(y);
        } */

        /* Fin Video 54) Generators */

        /* Video 55) Proxies */

        /* //objeto literal
        const persona = {
            nombre: "",
            apellido: "",
            edad: 0
        }

        //manejador o handler
        const manejador = {

            //establecer las validaciones, al momento de indicar las propiedades al objeto
            set(obj, prop, valor) {

                //condicional para que no se establezcan mas propiedad mediante un objeto creado
                if(Object.keys(obj).indexOf(prop) === -1 ){
                    return console.error(`La propiedad "${prop}" no existe en el objeto persona`);
                }

                if(
                    (prop === "nombre" || prop === "apellido" ) && 
                    !(/^[A-Za-zÑñÁáÉéÑÍiÓóÚú\s]+$/g.test(valor))
                ){
                    return console.error(`La propiedad ${prop} sólo acepta letras y espacios en blanco`);
                }

                //para que se puedar establecer valores a las propiedades del objeto
                obj[prop] = valor;
            }
        }

        //proxie = es generar instancias a traves de un objeto literal
        const jon = new Proxy(persona, manejador);

        jon.nombre = "Jon19";
        jon.apellido = "Mircha";
        jon.edad = 35;
        jon.twitter = "@jonmircha";//tambien afecta al objeto literal

        console.log(jon);

        console.log(persona); */

        /* Fin Video 55) Proxies */

        /* Video 56) Propiedades Dinámicas de los Objetos */

        /* const objetosUsuarios = {
            //creando propiedades dinamicas durante la declaracion del objeto
            [`id_${Math.round(Math.random()*100 + 5)}`]: "Valor Aleatorio"
        };

        const usuarios = ["Miguel", "Eloy", "Yolanda", "Erick", "Andres", "Sole", "Canela"];

        console.log(objetosUsuarios)

        usuarios.forEach((usuario, index) => {
            //creando propiedades del objeto que esta sin propiedades
            objetosUsuarios[`id_${index}`] = usuario;
        });

        console.log(objetosUsuarios) */


        /* Fin Video 56) Propiedades Dinámicas de los Objetos */

        /* Video JavaScript: 57. this */

        /* console.log(this);
        console.log(window);
        console.log(this === window);

        this.nombre = "Contexto global";
        console.log(this.nombre);

        function imprimir() {
            console.log(this.nombre);
        }
        imprimir();

        const obj = {
            nombre: "Contexto Objeto",
            imprimir: function() {
                console.log(this.nombre);
            }
        }

        obj.imprimir();

        const obj2 = {
            nombre:"Contexto Objeto 2",
            imprimir
        }

        obj2.imprimir();

        const obj3 = {
            nombre: "Contexto Objeto 3",
            //la funcion toma el ambito en donde se declaro el objeto
            imprimir: () => {
                console.log(this.nombre);
            }
        }

        obj.imprimir();

        function Persona(nombre) {
            this.nombre = nombre

            //return console.log(this.nombre);

            //esto es un clousere, en este caso utiliza el contexto global y por eso
            //imprime la variable que esta declarada alla porque dentro de esta
            //funcion no existe la varible nombre, crea un scope interno
            //return function() {
            //    console.log(this.nombre);
            //}

            //se usa arrow function ya que no genera scope interno si reconoce la variable nombre
            return() => console.log(this.nombre);
        }

        let jon = new Persona("Jon")
        jon(); */
        /* Fin Video JavaScript: 57. this */

        /* Video 58) call, apply, bind */

        /* console.log(this);

        this.lugar = "Contexto global";

        function saludar(saludo, aQuien){
            console.log(`${saludo} ${aQuien} desde el  ${this.lugar}`);
        }

        saludar("Hola", "Kenai");

        const obj = {
            lugar: "Contexto Objeto"
        }

        //llama el contexto del scope del objeto
        saludar.call(obj, "Hola", "Jon");
        saludar.call(null, "Hola", "Jon");
        saludar.call(this, "Hola", "Jon");

        //llama el contexto del scope del objeto
        saludar.apply(obj,["Adios", "Mircha"]);
        saludar.apply(null,["Adios", "Mircha"]);
        saludar.apply(this,["Adios", "Mircha"]);

        this.nombre = "Window";

        const persona = {
            nombre: "Jon",
            saludar: function(){
                console.log(`Hola ${this.nombre}`)
            }
        }

        persona.saludar();
        

        const otraPersona = {
            //enlaza el contexto del objeto persona y asi se imprime la propiedad que esta adentro
            //de este y no indica undefined
            saludar: persona.saludar.bind(persona),
            saludar2: persona.saludar.bind(this)
        }

        otraPersona.saludar();
        otraPersona.saludar2(); */
        /* Fin Video 58) call, apply, bind */

        /* Video 59) JSON */

        /* const json = {
            cadena: "Jon",
            numero: 35,
            booleano: true,
            arreglo: ["correr","programar","cocinar"],
            objeto: {
                twitter:"@jonmircha",
                email: "jonmircha@gmail.com"
            },
            nulo: null
        }

        console.log(json);

        //transforma de un cadena a un objeto, array, boolean, entero, detecta que tipo
        //de dato esta entre las comillas y lo convierte a dicho tipo de dato
        // En resumen: analiza una cadena de texto y la convierte en un objeto valido para js
        console.log(JSON.parse("{}"));

        console.log(JSON.parse("[1,2,3]"));

        console.log(JSON.parse("true"));

        console.log(JSON.parse("false"));

        console.log(JSON.parse("19"));

        //console.log(JSON.parse("'Hola Mundo'"));

        console.log(JSON.parse("null"));

        //console.log(JSON.parse("undefined"));


        //convierte en un objeto valido para js a cadena de texto
        console.log(JSON.stringify({}));

        //lo transforma a un JSON
        console.log(JSON.stringify({x:3,y:3})); */


        /* Fin Video 59) JSON */

        
        
    </script>
</body>
</html>